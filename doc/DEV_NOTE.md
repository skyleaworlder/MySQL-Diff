# DDL

## 1. CREATE TABLE

[About Table](https://dev.mysql.com/doc/refman/8.0/en/create-table.html)

### i. COLUMN

```sql
CREATE TABLE `Persons`
(
    `PersonID` int NOT NULL AUTO_INCREMENT,
    `HashID` int NOT NULL DEFAULT 0,
    `LastName` varchar(255),
    `FirstName` varchar(255),
    `Address` varchar(255),
    `City` varchar(255)
);
```

* Column Name
* Column Data Type
* Column Options

### ii. INDEX | KEY

```sql
CREATE TABLE Persons
(
    -- like above
    PRIMARY KEY `PersonID`,
    UNIQUE KEY `id_last_name` (`PersonID`, `LastName`) USING BTREE,
    KEY `HashID`
);
```

All Index or Keys are below Data Column Definitions.

* Index Type: PRIMARY / UNIQUE / KEY
* Index Name
* Index Options (Polymorphism)

### iii. CONSTRAINT

```sql
CREATE TABLE Persons
(
    -- like above
    CONSTRAINT `ck_id` CHECK (`PersonID` > 0),
    CONSTRAINT `Persons_ibfk_1` FOREIGN KEY (`HashID`) REFERENCES `Hash` (`id`) ON DELETE CASCADE
);
```

All Constraints are below Data Column Definitions: Check-Constraint and Foreign-Key-Constraint.

* Constraint Name
* Constraint Condition

### iv. TABLE OPTIONS (ABANDON)

Other Options Like "ENGINE", "CHARACTER SET"...

## 2. Differ

Now I have 2 Table/Trigger/View(s).

## 3. ALTER

### i. ALTER TABLE

ALTER TABLE need All Information Defined in Class Table:

```typescript
// repair should be a method of class
// repair need to know which column has AI...
public repair() {
    const name = this.table_name;
    const cols = this.columsn;
    const keys = this.keys;
    const cons = this.constraints;

    // ...
}
```

Firstly, Table Name is Needed Anyway. Because `ALTER TABLE` Statement Always need `tbl_name`.

#### a. COLUMN

Processing Columns First, so that Keys can be Processed Successfully.

```sql
-- src tbl_a: id, a1, a2, a3
CREATE TABLE `tbl_a` (
  `id` int NOT NULL AUTO_INCREMENT,
  `a1` int DEFAULT NULL,
  `a2` int DEFAULT NULL,
  `a3` int DEFAULT NULL
);

-- tar tbl_b: id, a1, a3, a4
CREATE TABLE `tbl_b` (
  `id` int NOT NULL AUTO_INCREMENT,
  `a1` varchar(63) DEFAULT NULL,
  `a4` int DEFAULT NULL
);
```

1. `id` pass;
2. `a1` matches Rule(å);
3. (`tbl_a` still has `a2`, `a3`) `a2` matches Rule(∫);
4. `a3` matches Rule(∫);
5. (`tbl_b` still has `a4`) `a4` matches Rule(ç).

(TODO: RENAME a Column when there is a Column in another Table...)

##### å. same name, different type / options

```sql
-- tar_ddl is: col_name col_data_type col_options
ALTER TABLE `tbl_name` MODIFY COLUMN [tar_ddl];
```

##### ∫. a column exists in source, but not in target

```sql
ALTER TABLE `tbl_name` DROP COLUMN `col_name`;
```

##### ç. a new column exists in target

```sql
ALTER TABLE `tbl_name` ADD COLUMN [tar_ddl];
```

#### b. KEY

```sql
-- src tbl_a pk:id; uk:name; uk:c_id,d_id; nk:d_id
CREATE TABLE `tbl_a` (
  `id` int NOT NULL AUTO_INCREMENT,
  `c_id` int NOT NULL COMMENT 'c_id',
  `name` varchar(62) NOT NULL DEFAULT '',
  `d_id` int NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`),
  UNIQUE KEY `nani` (`d_id`, `name`),
  UNIQUE KEY `c_id` (`c_id`,`d_id`),
  KEY `test_index_ibfk_2` (`d_id`)
);
```

```sql
-- tar tbl_b pk:c_id; uk:d_id,name; uk:c_id,d_id; nk:id
CREATE TABLE `tbl_b` (
  `c_id` int NOT NULL AUTO_INCREMENT COMMENT 'c_id',
  `id` int NOT NULL,
  `name` varchar(62) NOT NULL DEFAULT '',
  `d_id` int NOT NULL,
  PRIMARY KEY (`c_id`),
  KEY `uk_c_id_d_id` (`c_id`,`d_id`),
  UNIQUE KEY `name` (`d_id`, `name`),
  KEY `test_index_ibfk_1` (`id`)
);
```

1. `PRIMARY KEY (c_id)` matches Rule(å);
2. `UNIQUE KEY name` matches Rule(∫);
3. (`tbl_b` still has `uk_c_id_d_id`, `test_index_ibfk_1`) `KEY uk_c_id_d_id` matches Rule(ç);
4. `KEY test_index_ibfk_1` match Rule(∂);
5. (`tbl_a` still has `test_index_ibfk_2`) `KEY test_index_ibfk_2` matches Rule(ę).

##### å. PRIMARY KEY: different column

PRIMARY KEY need AUTO_INCREMENT Column.

```sql
-- fetch source & target column
-- if source auto_increment
-- src_ddl_without_ai: src_name src_data_type col_options_without_ai(generated by string method of DataOptions)
ALTER TABLE `tbl_name` MODIFY COLUMN [src_ddl_without_ai];

-- tar_ddl_with_ai: tar_name tar_data_type col_options_with_ai
ALTER TABLE `tbl_name` MODIFY COLUMN [tar_ddl_with_ai];

-- pk_ddl: PRIMARY KEY (`col_name`...) key_options
ALTER TABLE `tbl_name` DROP PRIMARY KEY, ADD [pk_ddl];
```

##### ∫. UNIQUE KEY: same name, different column

```sql
-- uk_ddl: UNIQUE KEY `uk_name` (`uk_part`) key_options
ALTER TABLE `tbl_name` DROP KEY `uk_name`, ADD [uk_ddl];
```

##### ç. UNIQUE KEY: different name, same column

if not any UNIQUE KEY that has the same name, Check All the KEYs.

```sql
ALTER TABLE `tbl_name` RENAME KEY `old_name` TO `new_name`;
```

##### ∂. PRIMARY / UNIQUE KEY: target have but source do not

```sql
ALTER TABLE `tbl_name` ADD [pk_ddl];
```

##### ę. PRIMARY / UNIQUE KEY: source have but target do not

```sql
ALTER TABLE `tbl_name` DROP KEY `key_name`;
```

#### c. CONSTRAINT

RENAME a CONSTRAINT is Impossible!!!

```sql
-- src tbl_a
CREATE TABLE `tbl_a` (
  `c1` int DEFAULT NULL,
  `c2` int DEFAULT NULL,
  `c3` int DEFAULT NULL,
  `c_id` int NOT NULL COMMENT 'c_id',
  `d_id` int NOT NULL,
  CONSTRAINT `test_constraint_chk_2` CHECK ((`c3` < 100)),
  CONSTRAINT `test_constraint_chk_3` CHECK ((`c1` <> `c2`)),
  CONSTRAINT `test_constraint_chk_4` CHECK ((`c1` > `c3`)),
  CONSTRAINT `test_index_ibfk_1` FOREIGN KEY (`c_id`, `d_id`) REFERENCES `test_datacolumn` (`c_id`, `id`) ON DELETE CASCADE
);
```

```sql
-- tar tbl_b
CREATE TABLE `test_constraint` (
  `c1` int DEFAULT NULL,
  `c2` int DEFAULT NULL,
  `c3` int DEFAULT NULL,
  `c_id` int NOT NULL COMMENT 'c_id',
  `d_id` int NOT NULL,
  CONSTRAINT `c1_nonzero` CHECK ((`c1` <> 0)),
  CONSTRAINT `test_constraint_chk_2` CHECK ((`c3` < 100)),
  CONSTRAINT `test_constraint_chk_3` CHECK ((`c1` <> `id`)),
  CONSTRAINT `test_constraint_chk_5` CHECK ((`c1` > `c3`)),
  CONSTRAINT `test_index_ibfk_1` FOREIGN KEY (`c_id`) REFERENCES `test_datacolumn` (`c_id`) ON DELETE CASCADE,
  CONSTRAINT `test_index_ibfk_2` FOREIGN KEY (`d_id`) REFERENCES `test_datacolumn` (`id`) ON DELETE CASCADE
);
```

1. `CONSTRAINT test_constraint_chk_2` pass;
2. `CONSTRAINT test_constraint_chk_3` matches Rule(å);
3. `test_index_ibfk_1` matches Rule(∫);
4. (`tbl_a` still has `test_constraint_chk_4`) `test_constraint_chk_4` matches Rule(∂);
5. (`tbl_b` still has `c1_nonzero`, `test_constraint_chk_5`, `test_index_ibfk_2`) `c1_nonzero` matches Rule(ç);
6. `test_constraint_chk_5` matches Rule(ç);
7. `test_index_ibfk_2` matches Rule(ç).

##### å. CHECK: same name, different conditions

```sql
-- ck_constraint_ddl: CONSTRAINT `constraint_name` CHECK check_conditions
ALTER TABLE `tbl_name` DROP CONSTRAINT `constraint_name`, ADD [ck_constraint_ddl];
```

##### ∫. FOREIGN KEY: same name, different info

Too complicated. Re-write them All!!!

```sql
-- fk_constraint_ddl: CONSTRAINT `constraint_name` FOREIGN KEY (cols) REFERENCES `ref_tbl` (ref_tbl_cols) constraint_option
ALTER TABLE `tbl_name` DROP CONSTRAINT `constraint_name`, ADD [fk_constraint_ddl];
```

##### ç. CHECK / FOREIGN KEY: target has, but source do not (different name)

```sql
-- constraint_ddl: CONSTRAINT `constraint_name` other_info
ALTER TABLE `tbl_name` ADD [constraint_ddl];
```

##### ∂. CHECK / FOREIGN KEY: source has, but target do not (different name)

```sql
ALTER TABLE `tbl_name` DROP CONSTRAINT `constraint_name`;
```
